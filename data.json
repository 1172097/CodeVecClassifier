[
    {
        "code_id": 1,
        "code": "def function(graph, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        print(start)  # Process the node\n\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(graph, neighbor, visited)\n        return visited",
        "label": "DFS"
    },
    {
        "code_id": 2,
        "code": "def function(graph, start):\n        visited = set()\n        queue = [start]\n        visited.add(start)\n\n        while queue:\n            node = queue.pop(0)\n            print(node)  # Process the node\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)",
        "label": "BFS"
    },
    {
        "code_id": 3,
        "code": "def function(graph, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        print(start)  # Process the node\n\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                function(graph, neighbor, visited)\n        return visited",
        "label": "DFS"
    },
    {
        "code_id": 4,
        "code": "\n    def function(graph, start):\n        visited = set()\n        stack = [start]\n        visited.add(start)\n\n        while stack:\n            node = stack.pop()\n            print(node)  # Process the node\n\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n                    visited.add(neighbor)",
        "label": "DFS"
    },
    {
        "code_id": 5,
        "code": "def binary_search_iterative(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "label": "Binary Search"
    },
    {
        "code_id": 6,
        "code": "def binary_search_recursive(arr, target, left, right):\n    if left > right:\n        return -1\n    mid = (left + right) // 2\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, mid + 1, right)\n    else:\n        return binary_search_recursive(arr, target, left, mid - 1)",
        "label": "Binary Search"
    },
    {
        "code_id": 7,
        "code": "def binary_search_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "label": "Binary Search"
    },
    {
        "code_id": 8,
        "code": "def binary_search_last_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
        "label": "Binary Search"
    },
    {
        "code_id": 9,
        "code": "def bubble_sort_1(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
        "label": "Bubble Sort"
    },
    {
        "code_id": 10,
        "code": "def bubble_sort_2(arr):\n    n = len(arr)\n    for i in range(n-1):\n        for j in range(n-1-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
        "label": "Bubble Sort"
    },
    {
        "code_id": 11,
        "code": "def bubble_sort_3(arr):\n    n = len(arr)\n    swapped = True\n    while swapped:\n        swapped = False\n        for i in range(1, n):\n            if arr[i-1] > arr[i]:\n                arr[i-1], arr[i] = arr[i], arr[i-1]\n                swapped = True\n        n -= 1",
        "label": "Bubble Sort"
    },
    {
        "code_id": 12,
        "code": "def bubble_sort_4(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break",
        "label": "Bubble Sort"
    },
    {
        "code_id": 13,
        "code": "def bfs_traversal(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        vertex = queue.popleft()\n        print(vertex, end=' ')\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)",
        "label": "BFS"
    },
    {
        "code_id": 14,
        "code": "def bfs_shortest_path(graph, start, goal):\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        (vertex, path) = queue.popleft()\n        if vertex in visited:\n            continue\n        for neighbor in graph[vertex]:\n            if neighbor == goal:\n                return path + [neighbor]\n            else:\n                queue.append((neighbor, path + [neighbor]))\n        visited.add(vertex)\n    return None",
        "label": "BFS"
    },
    {
        "code_id": 15,
        "code": "def bfs_path_exists(graph, start, goal):\n    queue = deque([start])\n    visited = set()\n    while queue:\n        vertex = queue.popleft()\n        if vertex == goal:\n            return True\n        if vertex not in visited:\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    return False",
        "label": "BFS"
    },
    {
        "code_id": 16,
        "code": "def dfs_all_paths(graph, start, goal, path=None, paths=None):\n    if path is None:\n        path = []\n    if paths is None:\n        paths = []\n    path = path + [start]\n    if start == goal:\n        paths.append(path)\n    else:\n        for neighbor in graph[start]:\n            if neighbor not in path:\n                dfs_all_paths(graph, neighbor, goal, path, paths)\n    return paths",
        "label": "DFS"
    },
    {
        "code_id": 17,
        "code": "def dfs_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited)\n    return visited",
        "label": "DFS"
    },
    {
        "code_id": 18,
        "code": "def dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            stack.extend(reversed(graph[node]))\n    return visited",
        "label": "DFS"
    },
    {
        "code_id": 19,
        "code": "def dfs_bipartite(color, adj, v, start):\n    if start in v:\n        return True\n    v.add(start)\n    for nei in adj[start]:\n        if color[nei - 1] == color[start - 1]:\n            return False\n        else:\n            color[nei - 1] = not color[start - 1]\n            if not dfs_bipartite(color, adj, v, nei):\n                return False\n    return True",
        "label": "DFS"
    },
    {
        "code_id": 20,
        "code": "def bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            print(node)\n            visited.add(node)\n            queue.extend(graph[node])\n    return visited",
        "label": "BFS"
    },
    {
        "code_id": 21,
        "code": "def bfs_with_levels(graph, start):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        node, level = queue.popleft()\n        if node not in visited:\n            print(f\"Node: {node}, Level: {level}\")\n            visited.add(node)\n            for neighbor in graph[node]:\n                queue.append((neighbor, level + 1))\n    return visited",
        "label": "BFS"
    },
    {
        "code_id": 22,
        "code": "def bfs_shortest_path(graph, start, goal):\n    queue = deque([(start, [start])])\n    while queue:\n        node, path = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor == goal:\n                return path + [neighbor]\n            else:\n                queue.append((neighbor, path + [neighbor]))\n    return None",
        "label": "BFS"
    },
    {
        "code_id": 23,
        "code": "def binary_search_closest(arr, target):\n    left, right = 0, len(arr) - 1\n    closest = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        if abs(arr[mid] - target) < abs(closest - target):\n            closest = arr[mid]\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return closest",
        "label": "Binary Search"
    },
    {
        "code_id": 24,
        "code": "def binary_search_rotated(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        if arr[left] <= arr[mid]:\n            if arr[left] <= target < arr[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if arr[mid] < target <= arr[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
        "label": "Binary Search"
    },
    {
        "code_id": 25,
        "code": "def binary_search_peak_element(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] > arr[mid + 1]:\n            right = mid\n        else:\n            left = mid + 1\n    return left",
        "label": "Binary Search"
    },
    {
        "code_id": 26,
        "code": "def bubble_sort_optimized(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(1, n-i):\n            if arr[j-1] > arr[j]:\n                arr[j-1], arr[j] = arr[j], arr[j-1]\n                swapped = True\n        if not swapped:\n            break",
        "label": "Bubble Sort"
    },
    {
        "code_id": 27,
        "code": "def bubble_sort_recursive(arr, n=None):\n    if n is None:\n        n = len(arr)\n    if n == 1:\n        return\n    for i in range(n-1):\n        if arr[i] > arr[i+1]:\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n    bubble_sort_recursive(arr, n-1)",
        "label": "Bubble Sort"
    },
    {
        "code_id": 28,
        "code": "def bubble_sort_flag(arr):\n    n = len(arr)\n    for i in range(n-1):\n        swapped = False\n        for j in range(n-1-i):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break",
        "label": "Bubble Sort"
    },
    {
    "code_id": 29,
    "code": "def dfs_detect_cycle(graph, node, visited, parent):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            if dfs_detect_cycle(graph, neighbor, visited, node):\n                return True\n        elif parent != neighbor:\n            return True\n    return False",
    "label": "DFS"
},
{
    "code_id": 30,
    "code": "def dfs_topological_sort(graph, node, visited, stack):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_topological_sort(graph, neighbor, visited, stack)\n    stack.append(node)",
    "label": "DFS"
},
{
    "code_id": 31,
    "code": "def dfs_connected_components(graph):\n    def dfs(node, visited, component):\n        visited.add(node)\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, component)\n    visited = set()\n    components = []\n    for node in graph:\n        if node not in visited:\n            component = []\n            dfs(node, visited, component)\n            components.append(component)\n    return components",
    "label": "DFS"
},
{
    "code_id": 32,
    "code": "def bfs_layered_traversal(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    layers = {start: 0}\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                layers[neighbor] = layers[node] + 1\n    return layers",
    "label": "BFS"
},
{
    "code_id": 33,
    "code": "def bfs_level_order(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    level_order = []\n    while queue:\n        node = queue.popleft()\n        level_order.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return level_order",
    "label": "BFS"
},
{
    "code_id": 34,
    "code": "def bfs_connected_components(graph):\n    visited = set()\n    components = []\n    for node in graph:\n        if node not in visited:\n            queue = deque([node])\n            component = []\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    component.append(current)\n                    queue.extend(graph[current])\n            components.append(component)\n    return components",
    "label": "BFS"
},
{
    "code_id": 35,
    "code": "def binary_search_floor(arr, target):\n    left, right = 0, len(arr) - 1\n    floor = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            floor = arr[mid]\n            left = mid + 1\n        else:\n            right = mid - 1\n    return floor",
    "label": "Binary Search"
},
{
    "code_id": 36,
    "code": "def binary_search_ceiling(arr, target):\n    left, right = 0, len(arr) - 1\n    ceiling = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] >= target:\n            ceiling = arr[mid]\n            right = mid - 1\n        else:\n            left = mid + 1\n    return ceiling",
    "label": "Binary Search"
},
{
    "code_id": 37,
    "code": "def binary_search_infinite_array(arr, target):\n    left, right = 0, 1\n    while target > arr[right]:\n        left = right\n        right *= 2\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "label": "Binary Search"
},
{
    "code_id": 38,
    "code": "def bubble_sort_reverse(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] < arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
    "label": "Bubble Sort"
},
{
    "code_id": 39,
    "code": "def bubble_sort_even_odd(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] % 2 == 0 and arr[j+1] % 2 != 0:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
    "label": "Bubble Sort"
},
{
    "code_id": 40,
    "code": "def bubble_sort_custom_comparator(arr, comp):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if comp(arr[j], arr[j+1]):\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
    "label": "Bubble Sort"
},
{
    "code_id": 41,
    "code": "def dfs_iterative(graph, start):\n    stack = [start]\n    visited = set()\n    result = []\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            result.append(node)\n            stack.extend(graph[node][::-1])\n    return result",
    "label": "DFS"
},
{
    "code_id": 42,
    "code": "def dfs_path_finder(graph, start, target):\n    def dfs(node, path):\n        if node == target:\n            return path\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                result = dfs(neighbor, path + [neighbor])\n                if result:\n                    return result\n        return None\n    visited = set()\n    return dfs(start, [start])",
    "label": "DFS"
},
{
    "code_id": 43,
    "code": "def dfs_all_paths(graph, start, target):\n    def dfs(node, path):\n        if node == target:\n            paths.append(path)\n            return\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                dfs(neighbor, path + [neighbor])\n    paths = []\n    dfs(start, [start])\n    return paths",
    "label": "DFS"
},
{
    "code_id": 44,
    "code": "def bfs_shortest_path(graph, start, target):\n    queue = deque([(start, [start])])\n    visited = set()\n    while queue:\n        node, path = queue.popleft()\n        if node == target:\n            return path\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, path + [neighbor]))\n    return None",
    "label": "BFS"
},
{
    "code_id": 45,
    "code": "def bfs_is_bipartite(graph):\n    color = {}\n    for start in graph:\n        if start not in color:\n            queue = deque([start])\n            color[start] = 0\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in color:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True",
    "label": "BFS"
},
{
    "code_id": 46,
    "code": "def bfs_tree_traversal(tree, root):\n    queue = deque([root])\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for child in tree[node]:\n            queue.append(child)\n    return result",
    "label": "BFS"
},
{
    "code_id": 47,
    "code": "def binary_search_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
    "label": "Binary Search"
},
{
    "code_id": 48,
    "code": "def binary_search_last_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result",
    "label": "Binary Search"
},
{
    "code_id": 49,
    "code": "def binary_search_rotated_array(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        if arr[left] <= arr[mid]:\n            if arr[left] <= target < arr[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if arr[mid] < target <= arr[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
    "label": "Binary Search"
},
{
    "code_id": 50,
    "code": "def bubble_sort_partial(arr, k):\n    n = len(arr)\n    for i in range(min(k, n)):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
    "label": "Bubble Sort"
},
{
    "code_id": 51,
    "code": "def bubble_sort_with_flag(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break",
    "label": "Bubble Sort"
},
{
    "code_id": 52,
    "code": "def bubble_sort_descending(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] < arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
    "label": "Bubble Sort"
},
{
    "code_id": 53,
    "code": "def bfs(graph, start):\n    visited = []\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.append(node)\n            queue.extend(graph[node])\n    return visited",
    "label": "BFS"
},
{
    "code_id": 54,
    "code": "def bfs_shortest_path(graph, start, goal):\n    queue = [(start, [start])]\n    while queue:\n        node, path = queue.pop(0)\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                if neighbor == goal:\n                    return path + [neighbor]\n                queue.append((neighbor, path + [neighbor]))\n    return None",
    "label": "BFS"
},
{
    "code_id": 55,
    "code": "def bfs_level_order(graph, start):\n    levels = {}\n    queue = [(start, 0)]\n\n    while queue:\n        node, level = queue.pop(0)\n        if node not in levels:\n            levels[node] = level\n            for neighbor in graph[node]:\n                queue.append((neighbor, level + 1))\n    return levels",
    "label": "BFS"
},
{
    "code_id": 56,
    "code": "def dfs_recursive(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited)\n    return visited",
    "label": "DFS"
},
{
    "code_id": 57,
    "code": "def dfs_iterative(graph, start):\n    visited = set()\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            stack.extend(graph[node])\n    return visited",
    "label": "DFS"
},
{
    "code_id": 58,
    "code": "def dfs_paths(graph, start, goal, path=None):\n    if path is None:\n        path = [start]\n    if start == goal:\n        return [path]\n    paths = []\n    for neighbor in graph[start]:\n        if neighbor not in path:\n            new_paths = dfs_paths(graph, neighbor, goal, path + [neighbor])\n            paths.extend(new_paths)\n    return paths",
    "label": "DFS"
},
{
    "code_id": 59,
    "code": "def binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1",
    "label": "Binary Search"
},
{
    "code_id": 60,
    "code": "def binary_search_recursive(arr, target, low, high):\n    if low > high:\n        return -1\n    mid = (low + high) // 2\n    if arr[mid] == target:\n        return mid\n    elif arr[mid] < target:\n        return binary_search_recursive(arr, target, mid + 1, high)\n    else:\n        return binary_search_recursive(arr, target, low, mid - 1)",
    "label": "Binary Search"
},
{
    "code_id": 61,
    "code": "def binary_search_find_first(arr, target):\n    low, high = 0, len(arr) - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            result = mid\n            high = mid - 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result",
    "label": "Binary Search"
},
{
    "code_id": 62,
    "code": "def bubble_sort_ascending(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
    "label": "Bubble Sort"
},
{
    "code_id": 63,
    "code": "def bubble_sort_descending(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] < arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
    "label": "Bubble Sort"
},
{
    "code_id": 64,
    "code": "def bubble_sort_with_flag(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr",
    "label": "Bubble Sort"
},
{
    "code_id": 65,
    "code": "def canVisitAllRooms(self, rooms: List[List[int]]):\n    q = deque()\n    q.append(0)\n    v = set()\n    while len(q) > 0:\n        curr = q.popleft()\n        if curr in v:\n            continue\n        v.add(curr)\n        for nei in rooms[curr]:\n            q.append(nei)\n    return len(v) == len(rooms)",
    "label": "BFS"
},
{
    "code_id": 66,
    "code": "def dfs_postorder(graph, start, visited=None, result=None):\n    if visited is None:\n        visited = set()\n    if result is None:\n        result = []\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs_postorder(graph, neighbor, visited, result)\n    result.append(start)\n    return result",
    "label": "DFS"
},
{
    "code_id": 67,
    "code": "def binary_search_range(arr, target):\n    def find_first():\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    def find_last():\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    first = find_first()\n    last = find_last()\n    if first <= last:\n        return [first, last]\n    return [-1, -1]",
    "label": "Binary Search"
},
{
    "code_id": 68,
    "code": "def bubble_sort_with_count(arr):\n    n = len(arr)\n    swap_count = 0\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                swap_count += 1\n    return arr, swap_count",
    "label": "Bubble Sort"
},
{
    "code_id": 69,
    "code": "def two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        current_sum = arr[left] + arr[right]\n        if current_sum == target:\n            return left, right\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return -1, -1",
    "label": "Two Pointers"
},
{
    "code_id": 70,
    "code": "def remove_duplicates(arr):\n    if not arr:\n        return 0\n    write_index = 1\n    for i in range(1, len(arr)):\n        if arr[i] != arr[i - 1]:\n            arr[write_index] = arr[i]\n            write_index += 1\n    return write_index",
    "label": "Two Pointers"
},
{
    "code_id": 71,
    "code": "def max_area(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        width = right - left\n        max_area = max(max_area, min(height[left], height[right]) * width)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area",
    "label": "Two Pointers"
},
{
    "code_id": 72,
    "code": "def is_palindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True",
    "label": "Two Pointers"
},
{
    "code_id": 73,
    "code": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged",
    "label": "Two Pointers"
},
{
    "code_id": 74,
    "code": "def max_sum_subarray(arr, k):\n    max_sum, window_sum = 0, 0\n    for i in range(len(arr)):\n        window_sum += arr[i]\n        if i >= k - 1:\n            max_sum = max(max_sum, window_sum)\n            window_sum -= arr[i - (k - 1)]\n    return max_sum",
    "label": "Sliding Window"
},
{
    "code_id": 75,
    "code": "def length_of_longest_substring(s):\n    char_index = {}\n    left = max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_index:\n            left = max(left, char_index[s[right]] + 1)\n        char_index[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 76,
    "code": "def min_subarray_len(target, arr):\n    left = 0\n    min_length = float('inf')\n    current_sum = 0\n    for right in range(len(arr)):\n        current_sum += arr[right]\n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= arr[left]\n            left += 1\n    return min_length if min_length != float('inf') else 0",
    "label": "Sliding Window"
},
{
    "code_id": 77,
    "code": "def length_of_longest_substring_k_distinct(s, k):\n    char_count = {}\n    left = max_length = 0\n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 78,
    "code": "from collections import deque\n\ndef max_sliding_window(nums, k):\n    deq = deque()\n    result = []\n    for i in range(len(nums)):\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n        while deq and nums[deq[-1]] < nums[i]:\n            deq.pop()\n        deq.append(i)\n        if i >= k - 1:\n            result.append(nums[deq[0]])\n    return result",
    "label": "Sliding Window"
},
{
    "code_id": 79,
    "code": "def three_sum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return result",
    "label": "Two Pointers"
},
{
    "code_id": 80,
    "code": "def reverse_string(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s",
    "label": "Two Pointers"
},
{
    "code_id": 81,
    "code": "def move_zeroes(nums):\n    left = 0\n    for right in range(len(nums)):\n        if nums[right] != 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n    return nums",
    "label": "Two Pointers"
},
{
    "code_id": 82,
    "code": "def find_pair_with_difference(nums, target):\n    nums.sort()\n    left, right = 0, 1\n    while right < len(nums):\n        if left == right or nums[right] - nums[left] < target:\n            right += 1\n        elif nums[right] - nums[left] > target:\n            left += 1\n        else:\n            return nums[left], nums[right]\n    return -1, -1",
    "label": "Two Pointers"
},
{
    "code_id": 83,
    "code": "def sorted_squares(nums):\n    n = len(nums)\n    result = [0] * n\n    left, right = 0, n - 1\n    for i in range(n - 1, -1, -1):\n        if abs(nums[left]) > abs(nums[right]):\n            result[i] = nums[left] ** 2\n            left += 1\n        else:\n            result[i] = nums[right] ** 2\n            right -= 1\n    return result",
    "label": "Two Pointers"
},
{
    "code_id": 84,
    "code": "def character_replacement(s, k):\n    count = {}\n    max_count = 0\n    left = 0\n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        if right - left + 1 - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n    return len(s) - left",
    "label": "Sliding Window"
},
{
    "code_id": 85,
    "code": "def find_anagrams(s, p):\n    from collections import Counter\n    p_count = Counter(p)\n    s_count = Counter()\n    result = []\n    left = 0\n    for right in range(len(s)):\n        s_count[s[right]] += 1\n        if right >= len(p):\n            if s_count[s[left]] == 1:\n                del s_count[s[left]]\n            else:\n                s_count[s[left]] -= 1\n            left += 1\n        if s_count == p_count:\n            result.append(left)\n    return result",
    "label": "Sliding Window"
},
{
    "code_id": 86,
    "code": "def longest_ones(nums, k):\n    left = 0\n    max_length = 0\n    zero_count = 0\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 87,
    "code": "def num_subarray_product_less_than_k(nums, k):\n    if k <= 1:\n        return 0\n    left = 0\n    product = 1\n    count = 0\n    for right in range(len(nums)):\n        product *= nums[right]\n        while product >= k:\n            product /= nums[left]\n            left += 1\n        count += right - left + 1\n    return count",
    "label": "Sliding Window"
},
{
    "code_id": 88,
    "code": "def check_inclusion(s1, s2):\n    from collections import Counter\n    s1_count = Counter(s1)\n    s2_count = Counter()\n    left = 0\n    for right in range(len(s2)):\n        s2_count[s2[right]] += 1\n        if right >= len(s1):\n            if s2_count[s2[left]] == 1:\n                del s2_count[s2[left]]\n            else:\n                s2_count[s2[left]] -= 1\n            left += 1\n        if s1_count == s2_count:\n            return True\n    return False",
    "label": "Sliding Window"
},
{
    "code_id": 89,
    "code": "def partition_array(nums, pivot):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        while left <= right and nums[left] < pivot:\n            left += 1\n        while left <= right and nums[right] >= pivot:\n            right -= 1\n        if left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    return nums",
    "label": "Two Pointers"
},
{
    "code_id": 90,
    "code": "def find_closest_pair(nums1, nums2, target):\n    nums1.sort()\n    nums2.sort()\n    left, right = 0, len(nums2) - 1\n    closest_sum = float('inf')\n    closest_pair = (-1, -1)\n    while left < len(nums1) and right >= 0:\n        current_sum = nums1[left] + nums2[right]\n        if abs(target - current_sum) < abs(target - closest_sum):\n            closest_sum = current_sum\n            closest_pair = (nums1[left], nums2[right])\n        if current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return closest_pair",
    "label": "Two Pointers"
},
{
    "code_id": 91,
    "code": "def dutch_national_flag(nums):\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[high], nums[mid] = nums[mid], nums[high]\n            high -= 1\n    return nums",
    "label": "Two Pointers"
},
{
    "code_id": 92,
    "code": "def intersect(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i, j = 0, 0\n    intersection = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] < nums2[j]:\n            i += 1\n        elif nums1[i] > nums2[j]:\n            j += 1\n        else:\n            intersection.append(nums1[i])\n            i += 1\n            j += 1\n    return intersection",
    "label": "Two Pointers"
},
{
    "code_id": 93,
    "code": "def longest_mountain(arr):\n    n = len(arr)\n    if n < 3:\n        return 0\n    longest = 0\n    for i in range(1, n - 1):\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            left, right = i - 1, i + 1\n            while left > 0 and arr[left - 1] < arr[left]:\n                left -= 1\n            while right < n - 1 and arr[right] < arr[right + 1]:\n                right += 1\n            longest = max(longest, right - left + 1)\n    return longest",
    "label": "Two Pointers"
},
{
    "code_id": 94,
    "code": "def length_of_longest_substring_two_distinct(s):\n    char_count = {}\n    left = max_length = 0\n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        while len(char_count) > 2:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 95,
    "code": "def max_vowels(s, k):\n    vowels = set('aeiou')\n    max_count = count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i >= k and s[i - k] in vowels:\n            count -= 1\n        max_count = max(max_count, count)\n    return max_count",
    "label": "Sliding Window"
},
{
    "code_id": 96,
    "code": "def longest_subarray_with_sum_at_most_k(nums, k):\n    left = 0\n    current_sum = 0\n    max_length = 0\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum > k:\n            current_sum -= nums[left]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 97,
    "code": "def find_max_average(nums, k):\n    max_sum = current_sum = sum(nums[:k])\n    for i in range(k, len(nums)):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum / k",
    "label": "Sliding Window"
},
{
    "code_id": 98,
    "code": "def number_of_subarrays(nums, k):\n    from collections import defaultdict\n    count = defaultdict(int)\n    count[0] = 1\n    odd_count = result = 0\n    for num in nums:\n        odd_count += num % 2\n        if odd_count >= k:\n            result += count[odd_count - k]\n        count[odd_count] += 1\n    return result",
    "label": "Sliding Window"
},
{
    "code_id": 99,
    "code": "def remove_element(nums, val):\n    left = 0\n    for right in range(len(nums)):\n        if nums[right] != val:\n            nums[left] = nums[right]\n            left += 1\n    return left",
    "label": "Two Pointers"
},
{
    "code_id": 100,
    "code": "def longest_subarray_with_sum_zero(nums):\n    sum_map = {}\n    max_length = 0\n    current_sum = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum == 0:\n            max_length = i + 1\n        elif current_sum in sum_map:\n            max_length = max(max_length, i - sum_map[current_sum])\n        else:\n            sum_map[current_sum] = i\n    return max_length",
    "label": "Two Pointers"
},
{
    "code_id": 101,
    "code": "def smallest_subarray_with_sum_greater_than_value(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    for right in range(len(nums)):\n        current_sum += nums[right]\n        while current_sum > target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    return min_length if min_length != float('inf') else 0",
    "label": "Sliding Window"
},
{
    "code_id": 102,
    "code": "def length_of_longest_substring_one_distinct(s):\n    char_count = {}\n    left = max_length = 0\n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        while len(char_count) > 1:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    "label": "Sliding Window"
},
{
    "code_id": 103,
    "code": "def permute(nums):\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    result = []\n    backtrack(0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 104,
    "code": "def subsets(nums):\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    result = []\n    backtrack(0, [])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 105,
    "code": "def combination_sum(candidates, target):\n    def backtrack(start, path, total):\n        if total == target:\n            result.append(path[:])\n            return\n        if total > target:\n            return\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])\n            path.pop()\n    result = []\n    backtrack(0, [], 0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 106,
    "code": "def partition(s):\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])\n            return\n        for i in range(start, len(s)):\n            if is_palindrome(s[start:i+1]):\n                path.append(s[start:i+1])\n                backtrack(i + 1, path)\n                path.pop()\n    result = []\n    backtrack(0, [])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 107,
    "code": "def solve_n_queens(n):\n    def backtrack(row):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if col in cols or row - col in diag1 or row + col in diag2:\n                continue\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            board[row][col] = 'Q'\n            backtrack(row + 1)\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n            board[row][col] = '.'\n    result = []\n    cols, diag1, diag2 = set(), set(), set()\n    board = [['.'] * n for _ in range(n)]\n    backtrack(0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 108,
    "code": "def exist(board, word):\n    def backtrack(r, c, i):\n        if i == len(word):\n            return True\n        if r < 0 or c < 0 or r >= len(board) or c >= len(board[0]) or board[r][c] != word[i]:\n            return False\n        temp, board[r][c] = board[r][c], '#'\n        found = any(backtrack(r + dr, c + dc, i + 1) for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n        board[r][c] = temp\n        return found\n    return any(backtrack(r, c, 0) for r in range(len(board)) for c in range(len(board[0])))",
    "label": "Backtracking"
},
{
    "code_id": 109,
    "code": "def combination_sum2(candidates, target):\n    def backtrack(start, path, total):\n        if total == target:\n            result.append(path[:])\n            return\n        if total > target:\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            backtrack(i + 1, path, total + candidates[i])\n            path.pop()\n    candidates.sort()\n    result = []\n    backtrack(0, [], 0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 110,
    "code": "def letter_combinations(digits):\n    def backtrack(index, path):\n        if index == len(digits):\n            result.append(''.join(path))\n            return\n        for letter in phone_map[digits[index]]:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    if not digits:\n        return []\n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    result = []\n    backtrack(0, [])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 111,
    "code": "def generate_parenthesis(n):\n    def backtrack(s, left, right):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    result = []\n    backtrack('', 0, 0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 112,
    "code": "def solve_sudoku(board):\n    def is_valid(r, c, k):\n        for i in range(9):\n            if board[i][c] == k or board[r][i] == k or board[r//3*3 + i//3][c//3*3 + i%3] == k:\n                return False\n        return True\n    def backtrack():\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == '.':\n                    for k in '123456789':\n                        if is_valid(r, c, k):\n                            board[r][c] = k\n                            if backtrack():\n                                return True\n                            board[r][c] = '.'\n                    return False\n        return True\n    backtrack()",
    "label": "Backtracking"
},
{
    "code_id": 113,
    "code": "def permute_unique(nums):\n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[start]:\n                continue\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n    nums.sort()\n    result = []\n    backtrack(0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 114,
    "code": "def combine(n, k):\n    def backtrack(start, path):\n        if len(path) == k:\n            result.append(path[:])\n            return\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n    result = []\n    backtrack(1, [])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 115,
    "code": "def restore_ip_addresses(s):\n    def backtrack(start, path):\n        if len(path) == 4:\n            if start == len(s):\n                result.append('.'.join(path))\n            return\n        for length in range(1, 4):\n            if start + length > len(s):\n                break\n            segment = s[start:start + length]\n            if (segment[0] == '0' and len(segment) > 1) or (length == 3 and int(segment) > 255):\n                continue\n            path.append(segment)\n            backtrack(start + length, path)\n            path.pop()\n    result = []\n    backtrack(0, [])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 116,
    "code": "def combination_sum3(k, n):\n    def backtrack(start, path, total):\n        if len(path) == k:\n            if total == n:\n                result.append(path[:])\n            return\n        for i in range(start, 10):\n            path.append(i)\n            backtrack(i + 1, path, total + i)\n            path.pop()\n    result = []\n    backtrack(1, [], 0)\n    return result",
    "label": "Backtracking"
},

{
    "code_id": 117,
    "code": "def gray_code(n):\n    def backtrack(path):\n        if len(path) == 1 << n:\n            result.append(path[:])\n            return\n        for i in range(n):\n            next_num = path[-1] ^ (1 << i)\n            if next_num not in path:\n                path.append(next_num)\n                backtrack(path)\n                path.pop()\n    result = []\n    backtrack([0])\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 118,
    "code": "def add_operators(num, target):\n    def backtrack(index, path, value, prev):\n        if index == len(num):\n            if value == target:\n                result.append(path)\n            return\n        for i in range(index, len(num)):\n            if i > index and num[index] == '0':\n                break\n            curr = int(num[index:i + 1])\n            if index == 0:\n                backtrack(i + 1, path + str(curr), curr, curr)\n            else:\n                backtrack(i + 1, path + '+' + str(curr), value + curr, curr)\n                backtrack(i + 1, path + '-' + str(curr), value - curr, -curr)\n                backtrack(i + 1, path + '*' + str(curr), value - prev + prev * curr, prev * curr)\n    result = []\n    backtrack(0, '', 0, 0)\n    return result",
    "label": "Backtracking"
},
{
    "code_id": 119,
    "code": "def makesquare(matchsticks):\n    def backtrack(index):\n        if index == len(matchsticks):\n            return all(side == target for side in sides)\n        for i in range(4):\n            if sides[i] + matchsticks[index] <= target:\n                sides[i] += matchsticks[index]\n                if backtrack(index + 1):\n                    return True\n                sides[i] -= matchsticks[index]\n            if sides[i] == 0:\n                break\n        return False\n    if not matchsticks or sum(matchsticks) % 4 != 0:\n        return False\n    target = sum(matchsticks) // 4\n    sides = [0] * 4\n    matchsticks.sort(reverse=True)\n    return backtrack(0)",
    "label": "Backtracking"
}








]
